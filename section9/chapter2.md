[ì¸í”„ëŸ° í•œì…í¬ê¸°ë¡œ ì˜ë¼ë¨¹ëŠ” íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ - ì´ì •í™˜](https://www.inflearn.com/course/%ED%95%9C%EC%9E%85-%ED%81%AC%EA%B8%B0-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/dashboard)ë‹˜ì˜ ê°•ì˜ë¥¼ ë³´ê³ 
ë‚´ìš©ì„ ì •ë¦¬í•œ í¬ìŠ¤íŒ…ì…ë‹ˆë‹¤
â‘ â‘¡â‘¢â‘£â‘¤â‘¥â‘¦â‘§â‘¨â‘©â‘ªâ‘«â‘¬â‘­â‘®

# ğŸ¥‡ infer

> ì¡°ê±´ë¶€íƒ€ì…ë‚´ì—ì„œ íŠ¹ì •íƒ€ì…ë§Œ ì¶”ë¡ í• ìˆ˜ìˆìŠµë‹ˆë‹¤.

## ì²« ë²ˆì§¸ ì˜ˆì‹œ

```tsx
type Func = â‘¢(â‘¤) => string;

type ReturnType<T> = â‘¡T extends â‘£(â‘¤) => string ? string : never;

type A = ReturnTypeâ‘ <Func>;

```

ì§„í–‰ê³¼ì •

> íƒ€ì…ë³€ìˆ˜â‘¡Tì— â‘ <Func> íƒ€ì…ì´ ë“¤ì–´ê°‘ë‹ˆë‹¤.
> â‘  === â‘¢() => string ì…ë‹ˆë‹¤.
> â‘£ () => string ì´ ë¹„êµí•˜ëŠ” íƒ€ì…ì…ë‹ˆë‹¤.
> â‘¢í‘í¬íƒ€ì…ì´ â‘£ì˜ ì„œë¸Œíƒ€ì…ì¸ì§€ ë¹„êµ ê°€ ì§„í–‰ë©ë‹ˆë‹¤.
> ê°™ë‹¤ë©´ string , ë‹¤ë¥´ë‹¤ë©´ nerver íƒ€ì…ì´ ë©ë‹ˆë‹¤.
> â‘¢,â‘£ ë‘ íƒ€ì…ì˜ ê´€ê³„ë¥¼ ë³´ë©´ â‘¤()ë§¤ê°œë³€ìˆ˜ëŠ” ì—†ìœ¼ë‹ˆ ë¹„êµí• ê²Œ ì—†ê³ 
> ë°˜í™˜ê°’ë§Œ ë³´ë©´ë˜ëŠ”ë° ë°˜í™˜ê°’ì´ ë”í°í•¨ìˆ˜ê°€ ìŠˆí¼íƒ€ì…ì´ ë©ë‹ˆë‹¤.
> ì§€ê¸ˆ â‘¢,â‘£ íƒ€ì…ì´ ë™ì¼í•˜ê¸°ì— ì„œë¸Œíƒ€ì…ì´ë¼ê³  ì·¨ê¸‰í• ìˆ˜ìˆìŠµë‹ˆë‹¤.
> ê·¸ë ‡ê¸°ì— string ì´ë¼ê³  í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## ë‘ë²ˆ ì§¸ ì˜ˆì‹œ

```tsx
type FuncA = () => string;
type FuncB = â‘¢() => number;

type ReturnType<T> = â‘ T extends â‘£() => string ? string : never;

type A = ReturnType<FuncA>;
type B = ReturnTypeâ‘¡<FuncB>; ë„¤ë²„íƒ€ì…ì´ ì¶”ë¡ ì´ ë©ë‹ˆë‹¤

```

> â‘ íƒ€ì…ë³€ìˆ˜Tì—ëŠ”â‘¡<FuncB>ê°€ ë“¤ì–´ê°‘ë‹ˆë‹¤.
> TëŠ” â‘¢()=>number ê°€ ë©ë‹ˆë‹¤.
> ê·¸ë¦¬ê³  TëŠ” â‘£() => string ê³¼ ë¹„êµí•˜ê²Œ ë˜ê³ 
> â‘¢â‘£ë¥¼ ë¹„êµí•˜ë‹ˆ ì„œë¡œì†Œ ì§‘í•© ì…ë‹ˆë‹¤.(ë‘˜ì¤‘ ëˆ„êµ¬ë„ ì„œë¸Œ,ìŠˆí¼ íƒ€ì…ì•„ë‹˜)
> ê·¸ëŸ¬ë¯€ë¡œ ì¡°ê±´ì‹ì€ ê±°ì§“ì´ë˜ê³  never ê°€ ì¶œë ¥ë©ë‹ˆë‹¤.

## ì„¸ë²ˆ ì§¸ ì˜ˆì‹œ

** infer ì‚¬ìš© **

```tsx
type FuncA = () => â‘¢string;
type FuncB = () => number;

type ReturnType<T> = â‘£T extends â‘ () => â‘¡infer R ? â‘¤R : never;

type A = ReturnType<FuncA>; ìŠ¤íŠ¸ë§ ì´ ì¶œë ¥ë©ë‹ˆë‹¤.
type B = ReturnType<FuncB>; ë„˜ë²„ê°€ ì¶œë ¥ë©ë‹ˆë‹¤.

```

> í•œìˆ˜ì˜ ë°˜í™˜ê°’ íƒ€ì…ì„ â‘  infer R : Rë¡œ ë³€ê²½í•´ì¤ë‹ˆë‹¤.
> â‘¡infer R ì´ë¼ê³  ì„ ì–¸í•œê²ƒì€ ì¼ë‹¨ Rì´ë¼ê³  ìƒê°í•©ë‹ˆë‹¤.
> A íƒ€ì…ì˜ ìƒí™©ì„ë³´ë©´ íƒ€ì…ë³€ìˆ˜Tì— FuncAê°€ ë“¤ì–´ê°”ìŠµë‹ˆë‹¤.
> â‘¢ === â‘£ ì´ ë˜ì—ˆê³  â‘£ê°€ () => infer R ì¸ì§€ ë¹„êµí•©ë‹ˆë‹¤.
> Ríƒ€ì…ì€ `FuncA === () =>R` ì°¸ìœ¼ë¡œ ë§Œë“œëŠ” íƒ€ì…ì„ ì¶”ë¡ í•˜ë„ë¡ ë™ì‘í•©ë‹ˆë‹¤.
> `FuncA === () =>R` ì°¸ì´ ë ë ¤ë©´ Rì´ string íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ ë©ë‹ˆë‹¤(ì„œë¸Œíƒ€ì…ì´ ë˜ì•¼í•˜ë¯€ë¡œ).
> ì°¸ì´ë˜ë©´ â‘¤R ì´ ë°˜í™˜ë˜ê³  Rì€ string ì´ë¯€ë¡œ string ì´ ì¶œë ¥ë©ë‹ˆë‹¤.

## ë„¤ë²ˆ ì§¸ ì˜ˆì‹œ

inferë‹¤ìŒì— ì˜¤ëŠ” ì¡°ê±´ì‹ì„ ì¶”ë¡  í•  ìˆ˜ ì—†ëŠ” ê²½ìš°ë¥¼ ** ì¡°ê±´ì‹ì´ ê±°ì§“ì´ ë©ë‹ˆë‹¤ **

```tsx
type FuncA = () => string;
type FuncB = () => number;

type ReturnType<T> = T extends â‘¡() => infer R ? R : never;

type A = ReturnType<FuncA>;
type B = ReturnType<FuncB>;
type C = ReturnType<â‘ number>;

```

> â‘ ë„˜ë²„íƒ€ì…ì´ ì´`â‘¡() => infer R`íƒ€ì…ì˜ ì„œë¸Œ íƒ€ì…ì´ ë  ìˆ˜ ìˆëŠ” Ríƒ€ì…ì˜ ì¡°ê±´ì„ ë§Œì¡±í• ìˆ˜ ì—†ì–´ ** ì¶”ë¡  ë¶ˆê°€ ** ìƒíƒœê°€ ë©ë‹ˆë‹¤.
> ì¡°ê±´ì‹ì´ ê±°ì§“ì´ë¼ íŒë‹¨ë˜ì–´ never ê°€ ì¶œë ¥ë©ë‹ˆë‹¤.

## ë‹¤ì„¯ ë²ˆì§¸ ì˜ˆì‹œ

```tsx
type RromiseUnpack<T> = â‘¡T extends â‘¢Promise<infer R> ? R : never;
1. TëŠ” í”„ë¡œë¯¸ìŠ¤ íƒ€ì…ì–´ì•¼í•œë‹¤. `T extends Promise<any> ? any : never;` ì´ëŸ´ ê²½ìš° í”„ë¡œë¯¸ìŠ¤ íƒ€ì…ì´ë©´ ë¬´ì¡°ê±´ anyë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

2. í”„ë¡œë¯¸ìŠ¤ íƒ€ì…ì˜ ê²°ê³¼ê°’ íƒ€ì…ì„ ë°˜í™˜í•´ì•¼ í•œë‹¤.
3.

type RromiseA = PromiseUnpack<â‘ Promise<number>>; // number íƒ€ì…ì´ ë˜ê¸¸ í¬ë§í•©ë‹ˆë‹¤
type RromiseA = PromiseUnpack<â‘ Promise<string>>; // string íƒ€ì…ì´ ë˜ê¸¸ í¬ë§í•©ë‹ˆë‹¤
```

> RromiseUnpack<T> ì—­í• ì€ Promise<number> ì˜ ê²°ê³¼ê°’ë§Œ ê°€ì ¸ì˜¤ëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í•©ë‹ˆë‹¤.
> â‘ Promise<number>ì„ â‘¡Tì— ì œê³µí•˜ëŠ” ìƒí™©
> â‘ Promise<number> íƒ€ì…ì´ â‘¢Promise<infer R> íƒ€ì…ì— ì„œë¸Œíƒ€ì…ì´ ë˜ëŠ” Ríƒ€ì…ì„ ì¶”ë¡ í•˜ê²Œ í•©ë‹ˆë‹¤.
> ì¦‰ number íƒ€ì…ì´ ë©ë‹ˆë‹¤.
